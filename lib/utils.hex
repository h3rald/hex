;;; _
;; a -> a
;; Duplicates and prints (with newline) the top item on the stack.
(dup puts) "_" ::

;;; cleanup
;; ->
;; Frees all symbols starting with an underscore (except for _).
(
 0x0 "_c" :
 (_c symbols len <)
   (
     symbols _c get "_item" :
     (_item "_" != 
      _item "_c" != 
      _item "_item" != 
      _item 0x0 get "_" ==
      and and and)
        (_item #)
      when 
      _c 0x1 + "_c" :
   )
 while
 "_item" #
 "_c" #
) "cleanup" ::

;; isi
;; a -> i
;; Pushes %%0x1%% on the stack if %:a%% is an integer, %%0x0%% otherwise.
(
  type "integer" ==
) "isi" ::

;; iss
;; a -> i
;; Pushes $0x1$$ on the stack if %:a%% is a string, $0x0$$ otherwise.
(
  type "string" ==
) "iss" ::

;; isq
;; a -> i
;; Pushes $0x1$$ on the stack if %%a%% is a quotation, $0x0$$ otherwise.
(
  type "quotation" ==
) "isq" ::

;;; ipop
;; s -> i
;; Stores symbol %%s%% by popping an integer from the stack, throws an error otherwise.
(
  "_id" :
  "_a" :
  (_a isi not)
    ("Integer required" throw)
  when 
  _a _id :
  cleanup
) "ipop" ::

;;; spop
;; s -> s
;; Stores symbol %%s%% by popping a string from the stack, throws an error otherwise.
(
  "_id" :
  "_a" :
  (_a iss not)
    ("String required" throw)
  when 
  _a _id :
  cleanup
) "spop" ::

;;; qpop
;; s -> q
;; Stores symbol %%s%% by popping a quotation from the stack, throws an error otherwise.
(
  "_id" :
  "_a" :
  (_a isq not)
    ("Quotation required" throw)
  when 
  _a _id :
  cleanup
) "qpop" ::

;;; lpop
;; s -> (q|s)
;; Stores symbol %%s%% by popping a quotation or a string from the stack, throws an error otherwise.
(
  "_id" :
  "_a" :
  (_a isi)
    ("String or quotation required" throw)
  when 
  _a _id :
  cleanup
) "lpop" ::

;; insert
;; (q1|s1) a i -> (q2|s2)
;; Inserts item %:a%% at position %:i%% within a quotation or string.
(
  "_index" ipop
  "_item" :
  "_list" lpop
  0x0 "_is-str" :
  _list len "_len" :
  (_index dup _len >= 0x0 < and)
    ("[symbol insert] Index out of bounds" fail)
  when
  (_list iss)
    ( 
      0x1 "_is-str" :
      (_item iss not)
        ("[symbol insert] A string item is required" fail)
      when
      _list "" split "_list" :
    )
  when
  0x0 "_c" :
  () "_result" :
  (_c _len <)
    (
      (_c _index ==)
        (_result _item ' cat "_result" :)
      when
      _result _list _c get ' cat "_result" :
      _c 0x1 + "_c" :
    )
  while
  (_is-str)
    (_result "" join "_result" :)
  when
  _result
  cleanup
) "insert" ::


;;; push
;; (q1|s1) a -> (q2|s2)
;; Pushes %:a%% to the end of a quotation or string.
(
  "_item" :
  "_list" lpop
  0x0 "_is-str" :
  (_list iss)
    (
      (_item iss not)
        ("[symbol push] A string item is required" fail)
      when
      0x1 "_is-str" :
      _list "" split "_list" :
    )
  when
  _list _item ' cat
  (_is-str)
    ( "" join)
  when
  cleanup
) "push" ::


;;; reverse
;; (q1|s1) -> (q2|s2)
;; Reverses the order of the elements in a string or quotation.
(
  "_list" lpop
  (_list iss)
    (_list "" split "_list" :)
  when
  _list len 0x1 - "_c" : 
  () "_result" :
  (_c 0x0 <=)
    (
       _result _list _c get ' cat "_result" :
       _c 0x1 - "_c" :
    )
  while
  _result
  (_list iss)
    (_result "" join "_result" :)
  when
  cleanup
) "reverse" ::



;;; sort
;; (q1|s1) q2 -> (q3|s2)
;; Sorts the items of a quotation or string.
(
  "_check" :
  "_list" lpop
  when
  (_list iss)
    (_list "" split "_list" :)
  when
  _list len "_len" :
  _list _len 0x1 - "_pivot" :
  0x0 "_c" :
  () "_left" :
  () "_right" :
  (0x1 len <=)
    (_list)
    (
      (_c len <)
        (
          (_list _c get _pivot _check .)
            (_left _item push "_left" :)
            (_right _item push "_right" :)
          if
          _c 0x1 + "_c" :
        )
      while
      _left sort pivot ' _right sort 
      cat cat "_result" :
    )
  if
  (_list iss)
    (_result "" join "_result" :)
  when
  _result
  cleanup
) "sort" ::


;;; replace-all
;; s1 s2 s3 -> s4
;; Replaces all occurrences of %:s2%% with %%s3%% in %:s1%%.
(
  "_rep"  :
  "_src"  :
  "_text" :
  (_text iss _src iss _rep iss and and not)
    ("[symbol replace-all] Three strings required." fail)
  when
  (_text _src index 0x0 >=)
    (_text _src _rep replace "_text" :)
  while
  _text
  cleanup
) "replace-all" :

;;; min
;; q -> a
;; Pushes the minimum item in a quotation on the stack.
(
  "_list" qpop
  () "_result" :
  (_list len 0x0 ==)
    ("[symbol min] Not enough items" fail)
  when
  0x0 get "_result" :
  0x1 "_c" :
  _list len "_len" :
  (_c len <)
    (
      (_result _list _c get <)
        (_list _c get "_result" :)
      when
    )
  while
  _result
  cleanup
) "min" ::

;;; max
;; q -> a
;; Pushes the maximum item in a quotation on the stack.
(
  "_list" qpop
  () "_result" :
  (_list len 0x0 ==)
    ("[symbol max] Not enough items" fail)
  when
  0x0 get "_result" :
  0x1 "_c" :
  _list len "_len" :
  (_c len <)
    (
      (_result _list _c get >)
        (_list _c get "_result" :)
      when
    )
  while
  _result
  cleanup
) "max" ::

;;; intpl
;; s1 q -> s2
;; Substitutes %:$0%% to %%$9%% placeholders in %:s1%% with items in %:q%%.
(
  "_s" spop
  "_q" qpop
  _q len "_len" :
  0x0 "_c" :
  (_c len <)
     (
       _s "$" _c str cat _list _c get cat replace-all "_s" :
       _c 0x1 + "_c" :
     )
   while
   cleanup
) "intpl" ::

;;; each
;; q1 q2 -> *
;; Applies %:q2%% to each element of %:q1%%.
(
  "_fn" qpop
  "_list" qpop
   _list len "_len" :
   0x0 "_c" :
   (_c len <)
     (
       _list _c get _fn .
       _c 0x1 + "_c" :
     )
   while
   cleanup
) "each" ::

;;; filter
;; q1 q2-> q3
;; Returns %:q3%% containing only the elements of %:q1%% that satisfy %:q2%%.

;;; begins
;; s1 s2 -> s3
;; Pushes $0x1$$ on the stack if %:s1%% begins with %:s2%%, or $0x0$$ otherwise.

;;; ends
;; s1 s2 -> s3
;; Pushes $0x1$$ on the stack if %:s1%% ends with %:s2%%, or $0x0$$ otherwise.

;;; slice
;; s1 i1 i2 -> s2
;; Extracts the portion of the string between indices %:i1%% and %:i2%%.

